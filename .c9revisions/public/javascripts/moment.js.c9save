{"ts":1369895133268,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1369895047272,"patch":[[{"diffs":[[1,"// moment.js\r\n// version : 2.0.0\r\n// author : Tim Wood\r\n// license : MIT\r\n// momentjs.com\r\n\r\n(function (undefined) {\r\n\r\n    /************************************\r\n        Constants\r\n    ************************************/\r\n\r\n    var moment,\r\n        VERSION = \"2.0.0\",\r\n        round = Math.round, i,\r\n        // internal storage for language config files\r\n        languages = {},\r\n\r\n        // check for nodeJS\r\n        hasModule = (typeof module !== 'undefined' && module.exports),\r\n\r\n        // ASP.NET json date format regex\r\n        aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i,\r\n\r\n        // format tokens\r\n        formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,\r\n        localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LT|LL?L?L?|l{1,4})/g,\r\n\r\n        // parsing tokens\r\n        parseMultipleFormatChunker = /([0-9a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+)/gi,\r\n\r\n        // parsing token regexes\r\n        parseTokenOneOrTwoDigits = /\\d\\d?/, // 0 - 99\r\n        parseTokenOneToThreeDigits = /\\d{1,3}/, // 0 - 999\r\n        parseTokenThreeDigits = /\\d{3}/, // 000 - 999\r\n        parseTokenFourDigits = /\\d{1,4}/, // 0 - 9999\r\n        parseTokenSixDigits = /[+\\-]?\\d{1,6}/, // -999,999 - 999,999\r\n        parseTokenWord = /[0-9]*[a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF]+\\s*?[\\u0600-\\u06FF]+/i, // any word (or two) characters or numbers including two word month in arabic.\r\n        parseTokenTimezone = /Z|[\\+\\-]\\d\\d:?\\d\\d/i, // +00:00 -00:00 +0000 -0000 or Z\r\n        parseTokenT = /T/i, // T (ISO seperator)\r\n        parseTokenTimestampMs = /[\\+\\-]?\\d+(\\.\\d{1,3})?/, // 123456789 123456789.123\r\n\r\n        // preliminary iso regex\r\n        // 0000-00-00 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000\r\n        isoRegex = /^\\s*\\d{4}-\\d\\d-\\d\\d((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d\\d?\\d?)?)?)?)?([\\+\\-]\\d\\d:?\\d\\d)?)?/,\r\n        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',\r\n\r\n        // iso time formats and regexes\r\n        isoTimes = [\r\n            ['HH:mm:ss.S', /(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d{1,3}/],\r\n            ['HH:mm:ss', /(T| )\\d\\d:\\d\\d:\\d\\d/],\r\n            ['HH:mm', /(T| )\\d\\d:\\d\\d/],\r\n            ['HH', /(T| )\\d\\d/]\r\n        ],\r\n\r\n        // timezone chunker \"+10:00\" > [\"10\", \"00\"] or \"-1530\" > [\"-15\", \"30\"]\r\n        parseTimezoneChunker = /([\\+\\-]|\\d\\d)/gi,\r\n\r\n        // getter and setter names\r\n        proxyGettersAndSetters = 'Month|Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),\r\n        unitMillisecondFactors = {\r\n            'Milliseconds' : 1,\r\n            'Seconds' : 1e3,\r\n            'Minutes' : 6e4,\r\n            'Hours' : 36e5,\r\n            'Days' : 864e5,\r\n            'Months' : 2592e6,\r\n            'Years' : 31536e6\r\n        },\r\n\r\n        // format function strings\r\n        formatFunctions = {},\r\n\r\n        // tokens to ordinalize and pad\r\n        ordinalizeTokens = 'DDD w W M D d'.split(' '),\r\n        paddedTokens = 'M D H h m s w W'.split(' '),\r\n\r\n        formatTokenFunctions = {\r\n            M    : function () {\r\n                return this.month() + 1;\r\n            },\r\n            MMM  : function (format) {\r\n                return this.lang().monthsShort(this, format);\r\n            },\r\n            MMMM : function (format) {\r\n                return this.lang().months(this, format);\r\n            },\r\n            D    : function () {\r\n                return this.date();\r\n            },\r\n            DDD  : function () {\r\n                return this.dayOfYear();\r\n            },\r\n            d    : function () {\r\n                return this.day();\r\n            },\r\n            dd   : function (format) {\r\n                return this.lang().weekdaysMin(this, format);\r\n            },\r\n            ddd  : function (format) {\r\n                return this.lang().weekdaysShort(this, format);\r\n            },\r\n            dddd : function (format) {\r\n                return this.lang().weekdays(this, format);\r\n            },\r\n            w    : function () {\r\n                return this.week();\r\n            },\r\n            W    : function () {\r\n                return this.isoWeek();\r\n            },\r\n            YY   : function () {\r\n                return leftZeroFill(this.year() % 100, 2);\r\n            },\r\n            YYYY : function () {\r\n                return leftZeroFill(this.year(), 4);\r\n            },\r\n            YYYYY : function () {\r\n                return leftZeroFill(this.year(), 5);\r\n            },\r\n            a    : function () {\r\n                return this.lang().meridiem(this.hours(), this.minutes(), true);\r\n            },\r\n            A    : function () {\r\n                return this.lang().meridiem(this.hours(), this.minutes(), false);\r\n            },\r\n            H    : function () {\r\n                return this.hours();\r\n            },\r\n            h    : function () {\r\n                return this.hours() % 12 || 12;\r\n            },\r\n            m    : function () {\r\n                return this.minutes();\r\n            },\r\n            s    : function () {\r\n                return this.seconds();\r\n            },\r\n            S    : function () {\r\n                return ~~(this.milliseconds() / 100);\r\n            },\r\n            SS   : function () {\r\n                return leftZeroFill(~~(this.milliseconds() / 10), 2);\r\n            },\r\n            SSS  : function () {\r\n                return leftZeroFill(this.milliseconds(), 3);\r\n            },\r\n            Z    : function () {\r\n                var a = -this.zone(),\r\n                    b = \"+\";\r\n                if (a < 0) {\r\n                    a = -a;\r\n                    b = \"-\";\r\n                }\r\n                return b + leftZeroFill(~~(a / 60), 2) + \":\" + leftZeroFill(~~a % 60, 2);\r\n            },\r\n            ZZ   : function () {\r\n                var a = -this.zone(),\r\n                    b = \"+\";\r\n                if (a < 0) {\r\n                    a = -a;\r\n                    b = \"-\";\r\n                }\r\n                return b + leftZeroFill(~~(10 * a / 6), 4);\r\n            },\r\n            X    : function () {\r\n                return this.unix();\r\n            }\r\n        };\r\n\r\n    function padToken(func, count) {\r\n        return function (a) {\r\n            return leftZeroFill(func.call(this, a), count);\r\n        };\r\n    }\r\n    function ordinalizeToken(func) {\r\n        return function (a) {\r\n            return this.lang().ordinal(func.call(this, a));\r\n        };\r\n    }\r\n\r\n    while (ordinalizeTokens.length) {\r\n        i = ordinalizeTokens.pop();\r\n        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i]);\r\n    }\r\n    while (paddedTokens.length) {\r\n        i = paddedTokens.pop();\r\n        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);\r\n    }\r\n    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);\r\n\r\n\r\n    /************************************\r\n        Constructors\r\n    ************************************/\r\n\r\n    function Language() {\r\n\r\n    }\r\n\r\n    // Moment prototype object\r\n    function Moment(config) {\r\n        extend(this, config);\r\n    }\r\n\r\n    // Duration Constructor\r\n    function Duration(duration) {\r\n        var data = this._data = {},\r\n            years = duration.years || duration.year || duration.y || 0,\r\n            months = duration.months || duration.month || duration.M || 0,\r\n            weeks = duration.weeks || duration.week || duration.w || 0,\r\n            days = duration.days || duration.day || duration.d || 0,\r\n            hours = duration.hours || duration.hour || duration.h || 0,\r\n            minutes = duration.minutes || duration.minute || duration.m || 0,\r\n            seconds = duration.seconds || duration.second || duration.s || 0,\r\n            milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;\r\n\r\n        // representation for dateAddRemove\r\n        this._milliseconds = milliseconds +\r\n            seconds * 1e3 + // 1000\r\n            minutes * 6e4 + // 1000 * 60\r\n            hours * 36e5; // 1000 * 60 * 60\r\n        // Because of dateAddRemove treats 24 hours as different from a\r\n        // day when working around DST, we need to store them separately\r\n        this._days = days +\r\n            weeks * 7;\r\n        // It is impossible translate months into days without knowing\r\n        // which months you are are talking about, so we have to store\r\n        // it separately.\r\n        this._months = months +\r\n            years * 12;\r\n\r\n        // The following code bubbles up values, see the tests for\r\n        // examples of what that means.\r\n        data.milliseconds = milliseconds % 1000;\r\n        seconds += absRound(milliseconds / 1000);\r\n\r\n        data.seconds = seconds % 60;\r\n        minutes += absRound(seconds / 60);\r\n\r\n        data.minutes = minutes % 60;\r\n        hours += absRound(minutes / 60);\r\n\r\n        data.hours = hours % 24;\r\n        days += absRound(hours / 24);\r\n\r\n        days += weeks * 7;\r\n        data.days = days % 30;\r\n\r\n        months += absRound(days / 30);\r\n\r\n        data.months = months % 12;\r\n        years += absRound(months / 12);\r\n\r\n        data.years = years;\r\n    }\r\n\r\n\r\n    /************************************\r\n        Helpers\r\n    ************************************/\r\n\r\n\r\n    function extend(a, b) {\r\n        for (var i in b) {\r\n            if (b.hasOwnProperty(i)) {\r\n                a[i] = b[i];\r\n            }\r\n        }\r\n        return a;\r\n    }\r\n\r\n    function absRound(number) {\r\n        if (number < 0) {\r\n            return Math.ceil(number);\r\n        } else {\r\n            return Math.floor(number);\r\n        }\r\n    }\r\n\r\n    // left zero fill a number\r\n    // see http://jsperf.com/left-zero-filling for performance comparison\r\n    function leftZeroFill(number, targetLength) {\r\n        var output = number + '';\r\n        while (output.length < targetLength) {\r\n            output = '0' + output;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    // helper function for _.addTime and _.subtractTime\r\n    function addOrSubtractDurationFromMoment(mom, duration, isAdding) {\r\n        var ms = duration._milliseconds,\r\n            d = duration._days,\r\n            M = duration._months,\r\n            currentDate;\r\n\r\n        if (ms) {\r\n            mom._d.setTime(+mom + ms * isAdding);\r\n        }\r\n        if (d) {\r\n            mom.date(mom.date() + d * isAdding);\r\n        }\r\n        if (M) {\r\n            currentDate = mom.date();\r\n            mom.date(1)\r\n                .month(mom.month() + M * isAdding)\r\n                .date(Math.min(currentDate, mom.daysInMonth()));\r\n        }\r\n    }\r\n\r\n    // check if is an array\r\n    function isArray(input) {\r\n        return Object.prototype.toString.call(input) === '[object Array]';\r\n    }\r\n\r\n    // compare two arrays, return the number of differences\r\n    function compareArrays(array1, array2) {\r\n        var len = Math.min(array1.length, array2.length),\r\n            lengthDiff = Math.abs(array1.length - array2.length),\r\n            diffs = 0,\r\n            i;\r\n        for (i = 0; i < len; i++) {\r\n            if (~~array1[i] !== ~~array2[i]) {\r\n                diffs++;\r\n            }\r\n        }\r\n        return diffs + lengthDiff;\r\n    }\r\n\r\n\r\n    /************************************\r\n        Languages\r\n    ************************************/\r\n\r\n\r\n    Language.prototype = {\r\n        set : function (config) {\r\n            var prop, i;\r\n            for (i in config) {\r\n                prop = config[i];\r\n                if (typeof prop === 'function') {\r\n                    this[i] = prop;\r\n                } else {\r\n                    this['_' + i] = prop;\r\n                }\r\n            }\r\n        },\r\n\r\n        _months : \"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),\r\n        months : function (m) {\r\n            return this._months[m.month()];\r\n        },\r\n\r\n        _monthsShort : \"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\".split(\"_\"),\r\n        monthsShort : function (m) {\r\n            return this._monthsShort[m.month()];\r\n        },\r\n\r\n        monthsParse : function (monthName) {\r\n            var i, mom, regex, output;\r\n\r\n            if (!this._monthsParse) {\r\n                this._monthsParse = [];\r\n            }\r\n\r\n            for (i = 0; i < 12; i++) {\r\n                // make the regex if we don't have it already\r\n                if (!this._monthsParse[i]) {\r\n                    mom = moment([2000, i]);\r\n                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\r\n                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\r\n                }\r\n                // test the regex\r\n                if (this._monthsParse[i].test(monthName)) {\r\n                    return i;\r\n                }\r\n            }\r\n        },\r\n\r\n        _weekdays : \"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),\r\n        weekdays : function (m) {\r\n            return this._weekdays[m.day()];\r\n        },\r\n\r\n        _weekdaysShort : \"Sun_Mon_Tue_Wed_Thu_Fri_Sat\".split(\"_\"),\r\n        weekdaysShort : function (m) {\r\n            return this._weekdaysShort[m.day()];\r\n        },\r\n\r\n        _weekdaysMin : \"Su_Mo_Tu_We_Th_Fr_Sa\".split(\"_\"),\r\n        weekdaysMin : function (m) {\r\n            return this._weekdaysMin[m.day()];\r\n        },\r\n\r\n        _longDateFormat : {\r\n            LT : \"h:mm A\",\r\n            L : \"MM/DD/YYYY\",\r\n            LL : \"MMMM D YYYY\",\r\n            LLL : \"MMMM D YYYY LT\",\r\n            LLLL : \"dddd, MMMM D YYYY LT\"\r\n        },\r\n        longDateFormat : function (key) {\r\n            var output = this._longDateFormat[key];\r\n            if (!output && this._longDateFormat[key.toUpperCase()]) {\r\n                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {\r\n                    return val.slice(1);\r\n                });\r\n                this._longDateFormat[key] = output;\r\n            }\r\n            return output;\r\n        },\r\n\r\n        meridiem : function (hours, minutes, isLower) {\r\n            if (hours > 11) {\r\n                return isLower ? 'pm' : 'PM';\r\n            } else {\r\n                return isLower ? 'am' : 'AM';\r\n            }\r\n        },\r\n\r\n        _calendar : {\r\n            sameDay : '[Today at] LT',\r\n            nextDay : '[Tomorrow at] LT',\r\n            nextWeek : 'dddd [at] LT',\r\n            lastDay : '[Yesterday at] LT',\r\n            lastWeek : '[Last] dddd [at] LT',\r\n            sameElse : 'L'\r\n        },\r\n        calendar : function (key, mom) {\r\n            var output = this._calendar[key];\r\n            return typeof output === 'function' ? output.apply(mom) : output;\r\n        },\r\n\r\n        _relativeTime : {\r\n            future : \"in %s\",\r\n            past : \"%s ago\",\r\n            s : \"a few seconds\",\r\n            m : \"a minute\",\r\n            mm : \"%d minutes\",\r\n            h : \"an hour\",\r\n            hh : \"%d hours\",\r\n            d : \"a day\",\r\n            dd : \"%d days\",\r\n            M : \"a month\",\r\n            MM : \"%d months\",\r\n            y : \"a year\",\r\n            yy : \"%d years\"\r\n        },\r\n        relativeTime : function (number, withoutSuffix, string, isFuture) {\r\n            var output = this._relativeTime[string];\r\n            return (typeof output === 'function') ?\r\n                output(number, withoutSuffix, string, isFuture) :\r\n                output.replace(/%d/i, number);\r\n        },\r\n        pastFuture : function (diff, output) {\r\n            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\r\n            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);\r\n        },\r\n\r\n        ordinal : function (number) {\r\n            return this._ordinal.replace(\"%d\", number);\r\n        },\r\n        _ordinal : \"%d\",\r\n\r\n        preparse : function (string) {\r\n            return string;\r\n        },\r\n\r\n        postformat : function (string) {\r\n            return string;\r\n        },\r\n\r\n        week : function (mom) {\r\n            return weekOfYear(mom, this._week.dow, this._week.doy);\r\n        },\r\n        _week : {\r\n            dow : 0, // Sunday is the first day of the week.\r\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\r\n        }\r\n    };\r\n\r\n    // Loads a language definition into the `languages` cache.  The function\r\n    // takes a key and optionally values.  If not in the browser and no values\r\n    // are provided, it will load the language file module.  As a convenience,\r\n    // this function also returns the language values.\r\n    function loadLang(key, values) {\r\n        values.abbr = key;\r\n        if (!languages[key]) {\r\n            languages[key] = new Language();\r\n        }\r\n        languages[key].set(values);\r\n        return languages[key];\r\n    }\r\n\r\n    // Determines which language definition to use and returns it.\r\n    //\r\n    // With no parameters, it will return the global language.  If you\r\n    // pass in a language key, such as 'en', it will return the\r\n    // definition for 'en', so long as 'en' has already been loaded using\r\n    // moment.lang.\r\n    function getLangDefinition(key) {\r\n        if (!key) {\r\n            return moment.fn._lang;\r\n        }\r\n        if (!languages[key] && hasModule) {\r\n            require('./lang/' + key);\r\n        }\r\n        return languages[key];\r\n    }\r\n\r\n\r\n    /************************************\r\n        Formatting\r\n    ************************************/\r\n\r\n\r\n    function removeFormattingTokens(input) {\r\n        if (input.match(/\\[.*\\]/)) {\r\n            return input.replace(/^\\[|\\]$/g, \"\");\r\n        }\r\n        return input.replace(/\\\\/g, \"\");\r\n    }\r\n\r\n    function makeFormatFunction(format) {\r\n        var array = format.match(formattingTokens), i, length;\r\n\r\n        for (i = 0, length = array.length; i < length; i++) {\r\n            if (formatTokenFunctions[array[i]]) {\r\n                array[i] = formatTokenFunctions[array[i]];\r\n            } else {\r\n                array[i] = removeFormattingTokens(array[i]);\r\n            }\r\n        }\r\n\r\n        return function (mom) {\r\n            var output = \"\";\r\n            for (i = 0; i < length; i++) {\r\n                output += typeof array[i].call === 'function' ? array[i].call(mom, format) : array[i];\r\n            }\r\n            return output;\r\n        };\r\n    }\r\n\r\n    // format date using native date object\r\n    function formatMoment(m, format) {\r\n        var i = 5;\r\n\r\n        function replaceLongDateFormatTokens(input) {\r\n            return m.lang().longDateFormat(input) || input;\r\n        }\r\n\r\n        while (i-- && localFormattingTokens.test(format)) {\r\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\r\n        }\r\n\r\n        if (!formatFunctions[format]) {\r\n            formatFunctions[format] = makeFormatFunction(format);\r\n        }\r\n\r\n        return formatFunctions[format](m);\r\n    }\r\n\r\n\r\n    /************************************\r\n        Parsing\r\n    ************************************/\r\n\r\n\r\n    // get the regex to find the next token\r\n    function getParseRegexForToken(token) {\r\n        switch (token) {\r\n        case 'DDDD':\r\n            return parseTokenThreeDigits;\r\n        case 'YYYY':\r\n            return parseTokenFourDigits;\r\n        case 'YYYYY':\r\n            return parseTokenSixDigits;\r\n        case 'S':\r\n        case 'SS':\r\n        case 'SSS':\r\n        case 'DDD':\r\n            return parseTokenOneToThreeDigits;\r\n        case 'MMM':\r\n        case 'MMMM':\r\n        case 'dd':\r\n        case 'ddd':\r\n        case 'dddd':\r\n        case 'a':\r\n        case 'A':\r\n            return parseTokenWord;\r\n        case 'X':\r\n            return parseTokenTimestampMs;\r\n        case 'Z':\r\n        case 'ZZ':\r\n            return parseTokenTimezone;\r\n        case 'T':\r\n            return parseTokenT;\r\n        case 'MM':\r\n        case 'DD':\r\n        case 'YY':\r\n        case 'HH':\r\n        case 'hh':\r\n        case 'mm':\r\n        case 'ss':\r\n        case 'M':\r\n        case 'D':\r\n        case 'd':\r\n        case 'H':\r\n        case 'h':\r\n        case 'm':\r\n        case 's':\r\n            return parseTokenOneOrTwoDigits;\r\n        default :\r\n            return new RegExp(token.replace('\\\\', ''));\r\n        }\r\n    }\r\n\r\n    // function to convert string input to date\r\n    function addTimeToArrayFromToken(token, input, config) {\r\n        var a, b,\r\n            datePartArray = config._a;\r\n\r\n        switch (token) {\r\n        // MONTH\r\n        case 'M' : // fall through to MM\r\n        case 'MM' :\r\n            datePartArray[1] = (input == null) ? 0 : ~~input - 1;\r\n            break;\r\n        case 'MMM' : // fall through to MMMM\r\n        case 'MMMM' :\r\n            a = getLangDefinition(config._l).monthsParse(input);\r\n            // if we didn't find a month name, mark the date as invalid.\r\n            if (a != null) {\r\n                datePartArray[1] = a;\r\n            } else {\r\n                config._isValid = false;\r\n            }\r\n            break;\r\n        // DAY OF MONTH\r\n        case 'D' : // fall through to DDDD\r\n        case 'DD' : // fall through to DDDD\r\n        case 'DDD' : // fall through to DDDD\r\n        case 'DDDD' :\r\n            if (input != null) {\r\n                datePartArray[2] = ~~input;\r\n            }\r\n            break;\r\n        // YEAR\r\n        case 'YY' :\r\n            datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2000);\r\n            break;\r\n        case 'YYYY' :\r\n        case 'YYYYY' :\r\n            datePartArray[0] = ~~input;\r\n            break;\r\n        // AM / PM\r\n        case 'a' : // fall through to A\r\n        case 'A' :\r\n            config._isPm = ((input + '').toLowerCase() === 'pm');\r\n            break;\r\n        // 24 HOUR\r\n        case 'H' : // fall through to hh\r\n        case 'HH' : // fall through to hh\r\n        case 'h' : // fall through to hh\r\n        case 'hh' :\r\n            datePartArray[3] = ~~input;\r\n            break;\r\n        // MINUTE\r\n        case 'm' : // fall through to mm\r\n        case 'mm' :\r\n            datePartArray[4] = ~~input;\r\n            break;\r\n        // SECOND\r\n        case 's' : // fall through to ss\r\n        case 'ss' :\r\n            datePartArray[5] = ~~input;\r\n            break;\r\n        // MILLISECOND\r\n        case 'S' :\r\n        case 'SS' :\r\n        case 'SSS' :\r\n            datePartArray[6] = ~~ (('0.' + input) * 1000);\r\n            break;\r\n        // UNIX TIMESTAMP WITH MS\r\n        case 'X':\r\n            config._d = new Date(parseFloat(input) * 1000);\r\n            break;\r\n        // TIMEZONE\r\n        case 'Z' : // fall through to ZZ\r\n        case 'ZZ' :\r\n            config._useUTC = true;\r\n            a = (input + '').match(parseTimezoneChunker);\r\n            if (a && a[1]) {\r\n                config._tzh = ~~a[1];\r\n            }\r\n            if (a && a[2]) {\r\n                config._tzm = ~~a[2];\r\n            }\r\n            // reverse offsets\r\n            if (a && a[0] === '+') {\r\n                config._tzh = -config._tzh;\r\n                config._tzm = -config._tzm;\r\n            }\r\n            break;\r\n        }\r\n\r\n        // if the input is null, the date is not valid\r\n        if (input == null) {\r\n            config._isValid = false;\r\n        }\r\n    }\r\n\r\n    // convert an array to a date.\r\n    // the array should mirror the parameters below\r\n    // note: all values past the year are optional and will default to the lowest possible value.\r\n    // [year, month, day , hour, minute, second, millisecond]\r\n    function dateFromArray(config) {\r\n        var i, date, input = [];\r\n\r\n        if (config._d) {\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < 7; i++) {\r\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\r\n        }\r\n\r\n        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid\r\n        input[3] += config._tzh || 0;\r\n        input[4] += config._tzm || 0;\r\n\r\n        date = new Date(0);\r\n\r\n        if (config._useUTC) {\r\n            date.setUTCFullYear(input[0], input[1], input[2]);\r\n            date.setUTCHours(input[3], input[4], input[5], input[6]);\r\n        } else {\r\n            date.setFullYear(input[0], input[1], input[2]);\r\n            date.setHours(input[3], input[4], input[5], input[6]);\r\n        }\r\n\r\n        config._d = date;\r\n    }\r\n\r\n    // date from string and format string\r\n    function makeDateFromStringAndFormat(config) {\r\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\r\n        var tokens = config._f.match(formattingTokens),\r\n            string = config._i,\r\n            i, parsedInput;\r\n\r\n        config._a = [];\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];\r\n            if (parsedInput) {\r\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\r\n            }\r\n            // don't parse if its not a known token\r\n            if (formatTokenFunctions[tokens[i]]) {\r\n                addTimeToArrayFromToken(tokens[i], parsedInput, config);\r\n            }\r\n        }\r\n        // handle am pm\r\n        if (config._isPm && config._a[3] < 12) {\r\n            config._a[3] += 12;\r\n        }\r\n        // if is 12 am, change hours to 0\r\n        if (config._isPm === false && config._a[3] === 12) {\r\n            config._a[3] = 0;\r\n        }\r\n        // return\r\n        dateFromArray(config);\r\n    }\r\n\r\n    // date from string and array of format strings\r\n    function makeDateFromStringAndArray(config) {\r\n        var tempConfig,\r\n            tempMoment,\r\n            bestMoment,\r\n\r\n            scoreToBeat = 99,\r\n            i,\r\n            currentScore;\r\n\r\n        for (i = config._f.length; i > 0; i--) {\r\n            tempConfig = extend({}, config);\r\n            tempConfig._f = config._f[i - 1];\r\n            makeDateFromStringAndFormat(tempConfig);\r\n            tempMoment = new Moment(tempConfig);\r\n\r\n            if (tempMoment.isValid()) {\r\n                bestMoment = tempMoment;\r\n                break;\r\n            }\r\n\r\n            currentScore = compareArrays(tempConfig._a, tempMoment.toArray());\r\n\r\n            if (currentScore < scoreToBeat) {\r\n                scoreToBeat = currentScore;\r\n                bestMoment = tempMoment;\r\n            }\r\n        }\r\n\r\n        extend(config, bestMoment);\r\n    }\r\n\r\n    // date from iso format\r\n    function makeDateFromString(config) {\r\n        var i,\r\n            string = config._i;\r\n        if (isoRegex.exec(string)) {\r\n            config._f = 'YYYY-MM-DDT';\r\n            for (i = 0; i < 4; i++) {\r\n                if (isoTimes[i][1].exec(string)) {\r\n                    config._f += isoTimes[i][0];\r\n                    break;\r\n                }\r\n            }\r\n            if (parseTokenTimezone.exec(string)) {\r\n                config._f += \" Z\";\r\n            }\r\n            makeDateFromStringAndFormat(config);\r\n        } else {\r\n            config._d = new Date(string);\r\n        }\r\n    }\r\n\r\n    function makeDateFromInput(config) {\r\n        var input = config._i,\r\n            matched = aspNetJsonRegex.exec(input);\r\n\r\n        if (input === undefined) {\r\n            config._d = new Date();\r\n        } else if (matched) {\r\n            config._d = new Date(+matched[1]);\r\n        } else if (typeof input === 'string') {\r\n            makeDateFromString(config);\r\n        } else if (isArray(input)) {\r\n            config._a = input.slice(0);\r\n            dateFromArray(config);\r\n        } else {\r\n            config._d = input instanceof Date ? new Date(+input) : new Date(input);\r\n        }\r\n    }\r\n\r\n\r\n    /************************************\r\n        Relative Time\r\n    ************************************/\r\n\r\n\r\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\r\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {\r\n        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\r\n    }\r\n\r\n    function relativeTime(milliseconds, withoutSuffix, lang) {\r\n        var seconds = round(Math.abs(milliseconds) / 1000),\r\n            minutes = round(seconds / 60),\r\n            hours = round(minutes / 60),\r\n            days = round(hours / 24),\r\n            years = round(days / 365),\r\n            args = seconds < 45 && ['s', seconds] ||\r\n                minutes === 1 && ['m'] ||\r\n                minutes < 45 && ['mm', minutes] ||\r\n                hours === 1 && ['h'] ||\r\n                hours < 22 && ['hh', hours] ||\r\n                days === 1 && ['d'] ||\r\n                days <= 25 && ['dd', days] ||\r\n                days <= 45 && ['M'] ||\r\n                days < 345 && ['MM', round(days / 30)] ||\r\n                years === 1 && ['y'] || ['yy', years];\r\n        args[2] = withoutSuffix;\r\n        args[3] = milliseconds > 0;\r\n        args[4] = lang;\r\n        return substituteTimeAgo.apply({}, args);\r\n    }\r\n\r\n\r\n    /************************************\r\n        Week of Year\r\n    ************************************/\r\n\r\n\r\n    // firstDayOfWeek       0 = sun, 6 = sat\r\n    //                      the day of the week that starts the week\r\n    //                      (usually sunday or monday)\r\n    // firstDayOfWeekOfYear 0 = sun, 6 = sat\r\n    //                      the first week is the week that contains the first\r\n    //                      of this day of the week\r\n    //                      (eg. ISO weeks use thursday (4))\r\n    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\r\n        var end = firstDayOfWeekOfYear - firstDayOfWeek,\r\n            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day();\r\n\r\n\r\n        if (daysToDayOfWeek > end) {\r\n            daysToDayOfWeek -= 7;\r\n        }\r\n\r\n        if (daysToDayOfWeek < end - 7) {\r\n            daysToDayOfWeek += 7;\r\n        }\r\n\r\n        return Math.ceil(moment(mom).add('d', daysToDayOfWeek).dayOfYear() / 7);\r\n    }\r\n\r\n\r\n    /************************************\r\n        Top Level Functions\r\n    ************************************/\r\n\r\n    function makeMoment(config) {\r\n        var input = config._i,\r\n            format = config._f;\r\n\r\n        if (input === null || input === '') {\r\n            return null;\r\n        }\r\n\r\n        if (typeof input === 'string') {\r\n            config._i = input = getLangDefinition().preparse(input);\r\n        }\r\n\r\n        if (moment.isMoment(input)) {\r\n            config = extend({}, input);\r\n            config._d = new Date(+input._d);\r\n        } else if (format) {\r\n            if (isArray(format)) {\r\n                makeDateFromStringAndArray(config);\r\n            } else {\r\n                makeDateFromStringAndFormat(config);\r\n            }\r\n        } else {\r\n            makeDateFromInput(config);\r\n        }\r\n\r\n        return new Moment(config);\r\n    }\r\n\r\n    moment = function (input, format, lang) {\r\n        return makeMoment({\r\n            _i : input,\r\n            _f : format,\r\n            _l : lang,\r\n            _isUTC : false\r\n        });\r\n    };\r\n\r\n    // creating with utc\r\n    moment.utc = function (input, format, lang) {\r\n        return makeMoment({\r\n            _useUTC : true,\r\n            _isUTC : true,\r\n            _l : lang,\r\n            _i : input,\r\n            _f : format\r\n        });\r\n    };\r\n\r\n    // creating with unix timestamp (in seconds)\r\n    moment.unix = function (input) {\r\n        return moment(input * 1000);\r\n    };\r\n\r\n    // duration\r\n    moment.duration = function (input, key) {\r\n        var isDuration = moment.isDuration(input),\r\n            isNumber = (typeof input === 'number'),\r\n            duration = (isDuration ? input._data : (isNumber ? {} : input)),\r\n            ret;\r\n\r\n        if (isNumber) {\r\n            if (key) {\r\n                duration[key] = input;\r\n            } else {\r\n                duration.milliseconds = input;\r\n            }\r\n        }\r\n\r\n        ret = new Duration(duration);\r\n\r\n        if (isDuration && input.hasOwnProperty('_lang')) {\r\n            ret._lang = input._lang;\r\n        }\r\n\r\n        return ret;\r\n    };\r\n\r\n    // version number\r\n    moment.version = VERSION;\r\n\r\n    // default format\r\n    moment.defaultFormat = isoFormat;\r\n\r\n    // This function will load languages and then set the global language.  If\r\n    // no arguments are passed in, it will simply return the current global\r\n    // language key.\r\n    moment.lang = function (key, values) {\r\n        var i;\r\n\r\n        if (!key) {\r\n            return moment.fn._lang._abbr;\r\n        }\r\n        if (values) {\r\n            loadLang(key, values);\r\n        } else if (!languages[key]) {\r\n            getLangDefinition(key);\r\n        }\r\n        moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);\r\n    };\r\n\r\n    // returns language data\r\n    moment.langData = function (key) {\r\n        if (key && key._lang && key._lang._abbr) {\r\n            key = key._lang._abbr;\r\n        }\r\n        return getLangDefinition(key);\r\n    };\r\n\r\n    // compare moment object\r\n    moment.isMoment = function (obj) {\r\n        return obj instanceof Moment;\r\n    };\r\n\r\n    // for typechecking Duration objects\r\n    moment.isDuration = function (obj) {\r\n        return obj instanceof Duration;\r\n    };\r\n\r\n\r\n    /************************************\r\n        Moment Prototype\r\n    ************************************/\r\n\r\n\r\n    moment.fn = Moment.prototype = {\r\n\r\n        clone : function () {\r\n            return moment(this);\r\n        },\r\n\r\n        valueOf : function () {\r\n            return +this._d;\r\n        },\r\n\r\n        unix : function () {\r\n            return Math.floor(+this._d / 1000);\r\n        },\r\n\r\n        toString : function () {\r\n            return this.format(\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\");\r\n        },\r\n\r\n        toDate : function () {\r\n            return this._d;\r\n        },\r\n\r\n        toJSON : function () {\r\n            return moment(this).utc().format('YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\r\n        },\r\n\r\n        toArray : function () {\r\n            var m = this;\r\n            return [\r\n                m.year(),\r\n                m.month(),\r\n                m.date(),\r\n                m.hours(),\r\n                m.minutes(),\r\n                m.seconds(),\r\n                m.milliseconds()\r\n            ];\r\n        },\r\n\r\n        isValid : function () {\r\n            if (this._isValid == null) {\r\n                if (this._a) {\r\n                    this._isValid = !compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray());\r\n                } else {\r\n                    this._isValid = !isNaN(this._d.getTime());\r\n                }\r\n            }\r\n            return !!this._isValid;\r\n        },\r\n\r\n        utc : function () {\r\n            this._isUTC = true;\r\n            return this;\r\n        },\r\n\r\n        local : function () {\r\n            this._isUTC = false;\r\n            return this;\r\n        },\r\n\r\n        format : function (inputString) {\r\n            var output = formatMoment(this, inputString || moment.defaultFormat);\r\n            return this.lang().postformat(output);\r\n        },\r\n\r\n        add : function (input, val) {\r\n            var dur;\r\n            // switch args to support add('s', 1) and add(1, 's')\r\n            if (typeof input === 'string') {\r\n                dur = moment.duration(+val, input);\r\n            } else {\r\n                dur = moment.duration(input, val);\r\n            }\r\n            addOrSubtractDurationFromMoment(this, dur, 1);\r\n            return this;\r\n        },\r\n\r\n        subtract : function (input, val) {\r\n            var dur;\r\n            // switch args to support subtract('s', 1) and subtract(1, 's')\r\n            if (typeof input === 'string') {\r\n                dur = moment.duration(+val, input);\r\n            } else {\r\n                dur = moment.duration(input, val);\r\n            }\r\n            addOrSubtractDurationFromMoment(this, dur, -1);\r\n            return this;\r\n        },\r\n\r\n        diff : function (input, units, asFloat) {\r\n            var that = this._isUTC ? moment(input).utc() : moment(input).local(),\r\n                zoneDiff = (this.zone() - that.zone()) * 6e4,\r\n                diff, output;\r\n\r\n            if (units) {\r\n                // standardize on singular form\r\n                units = units.replace(/s$/, '');\r\n            }\r\n\r\n            if (units === 'year' || units === 'month') {\r\n                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2\r\n                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());\r\n                output += ((this - moment(this).startOf('month')) - (that - moment(that).startOf('month'))) / diff;\r\n                if (units === 'year') {\r\n                    output = output / 12;\r\n                }\r\n            } else {\r\n                diff = (this - that) - zoneDiff;\r\n                output = units === 'second' ? diff / 1e3 : // 1000\r\n                    units === 'minute' ? diff / 6e4 : // 1000 * 60\r\n                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60\r\n                    units === 'day' ? diff / 864e5 : // 1000 * 60 * 60 * 24\r\n                    units === 'week' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7\r\n                    diff;\r\n            }\r\n            return asFloat ? output : absRound(output);\r\n        },\r\n\r\n        from : function (time, withoutSuffix) {\r\n            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);\r\n        },\r\n\r\n        fromNow : function (withoutSuffix) {\r\n            return this.from(moment(), withoutSuffix);\r\n        },\r\n\r\n        calendar : function () {\r\n            var diff = this.diff(moment().startOf('day'), 'days', true),\r\n                format = diff < -6 ? 'sameElse' :\r\n                diff < -1 ? 'lastWeek' :\r\n                diff < 0 ? 'lastDay' :\r\n                diff < 1 ? 'sameDay' :\r\n                diff < 2 ? 'nextDay' :\r\n                diff < 7 ? 'nextWeek' : 'sameElse';\r\n            return this.format(this.lang().calendar(format, this));\r\n        },\r\n\r\n        isLeapYear : function () {\r\n            var year = this.year();\r\n            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\r\n        },\r\n\r\n        isDST : function () {\r\n            return (this.zone() < moment([this.year()]).zone() ||\r\n                this.zone() < moment([this.year(), 5]).zone());\r\n        },\r\n\r\n        day : function (input) {\r\n            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\r\n            return input == null ? day :\r\n                this.add({ d : input - day });\r\n        },\r\n\r\n        startOf: function (units) {\r\n            units = units.replace(/s$/, '');\r\n            // the following switch intentionally omits break keywords\r\n            // to utilize falling through the cases.\r\n            switch (units) {\r\n            case 'year':\r\n                this.month(0);\r\n                /* falls through */\r\n            case 'month':\r\n                this.date(1);\r\n                /* falls through */\r\n            case 'week':\r\n            case 'day':\r\n                this.hours(0);\r\n                /* falls through */\r\n            case 'hour':\r\n                this.minutes(0);\r\n                /* falls through */\r\n            case 'minute':\r\n                this.seconds(0);\r\n                /* falls through */\r\n            case 'second':\r\n                this.milliseconds(0);\r\n                /* falls through */\r\n            }\r\n\r\n            // weeks are a special case\r\n            if (units === 'week') {\r\n                this.day(0);\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        endOf: function (units) {\r\n            return this.startOf(units).add(units.replace(/s?$/, 's'), 1).subtract('ms', 1);\r\n        },\r\n\r\n        isAfter: function (input, units) {\r\n            units = typeof units !== 'undefined' ? units : 'millisecond';\r\n            return +this.clone().startOf(units) > +moment(input).startOf(units);\r\n        },\r\n\r\n        isBefore: function (input, units) {\r\n            units = typeof units !== 'undefined' ? units : 'millisecond';\r\n            return +this.clone().startOf(units) < +moment(input).startOf(units);\r\n        },\r\n\r\n        isSame: function (input, units) {\r\n            units = typeof units !== 'undefined' ? units : 'millisecond';\r\n            return +this.clone().startOf(units) === +moment(input).startOf(units);\r\n        },\r\n\r\n        zone : function () {\r\n            return this._isUTC ? 0 : this._d.getTimezoneOffset();\r\n        },\r\n\r\n        daysInMonth : function () {\r\n            return moment.utc([this.year(), this.month() + 1, 0]).date();\r\n        },\r\n\r\n        dayOfYear : function (input) {\r\n            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;\r\n            return input == null ? dayOfYear : this.add(\"d\", (input - dayOfYear));\r\n        },\r\n\r\n        isoWeek : function (input) {\r\n            var week = weekOfYear(this, 1, 4);\r\n            return input == null ? week : this.add(\"d\", (input - week) * 7);\r\n        },\r\n\r\n        week : function (input) {\r\n            var week = this.lang().week(this);\r\n            return input == null ? week : this.add(\"d\", (input - week) * 7);\r\n        },\r\n\r\n        // If passed a language key, it will set the language for this\r\n        // instance.  Otherwise, it will return the language configuration\r\n        // variables for this instance.\r\n        lang : function (key) {\r\n            if (key === undefined) {\r\n                return this._lang;\r\n            } else {\r\n                this._lang = getLangDefinition(key);\r\n                return this;\r\n            }\r\n        }\r\n    };\r\n\r\n    // helper for adding shortcuts\r\n    function makeGetterAndSetter(name, key) {\r\n        moment.fn[name] = moment.fn[name + 's'] = function (input) {\r\n            var utc = this._isUTC ? 'UTC' : '';\r\n            if (input != null) {\r\n                this._d['set' + utc + key](input);\r\n                return this;\r\n            } else {\r\n                return this._d['get' + utc + key]();\r\n            }\r\n        };\r\n    }\r\n\r\n    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)\r\n    for (i = 0; i < proxyGettersAndSetters.length; i ++) {\r\n        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);\r\n    }\r\n\r\n    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')\r\n    makeGetterAndSetter('year', 'FullYear');\r\n\r\n    // add plural methods\r\n    moment.fn.days = moment.fn.day;\r\n    moment.fn.weeks = moment.fn.week;\r\n    moment.fn.isoWeeks = moment.fn.isoWeek;\r\n\r\n    /************************************\r\n        Duration Prototype\r\n    ************************************/\r\n\r\n\r\n    moment.duration.fn = Duration.prototype = {\r\n        weeks : function () {\r\n            return absRound(this.days() / 7);\r\n        },\r\n\r\n        valueOf : function () {\r\n            return this._milliseconds +\r\n              this._days * 864e5 +\r\n              this._months * 2592e6;\r\n        },\r\n\r\n        humanize : function (withSuffix) {\r\n            var difference = +this,\r\n                output = relativeTime(difference, !withSuffix, this.lang());\r\n\r\n            if (withSuffix) {\r\n                output = this.lang().pastFuture(difference, output);\r\n            }\r\n\r\n            return this.lang().postformat(output);\r\n        },\r\n\r\n        lang : moment.fn.lang\r\n    };\r\n\r\n    function makeDurationGetter(name) {\r\n        moment.duration.fn[name] = function () {\r\n            return this._data[name];\r\n        };\r\n    }\r\n\r\n    function makeDurationAsGetter(name, factor) {\r\n        moment.duration.fn['as' + name] = function () {\r\n            return +this / factor;\r\n        };\r\n    }\r\n\r\n    for (i in unitMillisecondFactors) {\r\n        if (unitMillisecondFactors.hasOwnProperty(i)) {\r\n            makeDurationAsGetter(i, unitMillisecondFactors[i]);\r\n            makeDurationGetter(i.toLowerCase());\r\n        }\r\n    }\r\n\r\n    makeDurationAsGetter('Weeks', 6048e5);\r\n\r\n\r\n    /************************************\r\n        Default Lang\r\n    ************************************/\r\n\r\n\r\n    // Set default language, other languages will inherit from English.\r\n    moment.lang('en', {\r\n        ordinal : function (number) {\r\n            var b = number % 10,\r\n                output = (~~ (number % 100 / 10) === 1) ? 'th' :\r\n                (b === 1) ? 'st' :\r\n                (b === 2) ? 'nd' :\r\n                (b === 3) ? 'rd' : 'th';\r\n            return number + output;\r\n        }\r\n    });\r\n\r\n\r\n    /************************************\r\n        Exposing Moment\r\n    ************************************/\r\n\r\n\r\n    // CommonJS module is defined\r\n    if (hasModule) {\r\n        module.exports = moment;\r\n    }\r\n    /*global ender:false */\r\n    if (typeof ender === 'undefined') {\r\n        // here, `this` means `window` in the browser, or `global` on the server\r\n        // add `moment` as a global object via a string identifier,\r\n        // for Closure Compiler \"advanced\" mode\r\n        this['moment'] = moment;\r\n    }\r\n    /*global define:false */\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"moment\", [], function () {\r\n            return moment;\r\n        });\r\n    }\r\n}).call(this);"]],"start1":0,"start2":0,"length1":0,"length2":45294}]],"length":45294,"saved":false}
